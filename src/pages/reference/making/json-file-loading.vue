<template>

    <!-- 機能 -->
    <compatible-device ref="compatibleDevice1Ref"/>

    <!-- 以降、ページ -->
    <the-app-header/>
    <button-to-back-to-contents
        class="sec-0 mt-6"
        pagePath="../"
    />

    <h1>JSONファイルを読込もうぜ！</h1>

    <button-to-go-to-top class="sec-1 pt-6"/>
    <h2>fetch() と useFetch()</h2>
    <section class="sec-2 pt-6">


        <talk-balloon
            :src="oton2Src"
            :alt="oton2Alt"
            :name="oton2Name"
            :device="compatibleDevice1Ref?.device"
        >
            JSONファイル１つ読み込むにもやり方がいくつかあるんで、その違いをメモしておこうぜ。
        </talk-balloon>


        <talk-balloon
            :src="kifuwarabe2Src"
            :alt="kifuwarabe2Alt"
            :name="kifuwarabe2Name"
            :device="compatibleDevice1Ref?.device"
        >
            👇 じゃあ、以下の２か所に JSON ファイルを置いておくぜ。
        </talk-balloon>


        <p>📄 <a target="_blank" :href="jsonFilePathPublic">public{{jsonFilePathPublic}}</a>:</p>
        <pre class="coding-example mb-6">
{
    "#this-file": "publicフォルダー下に置いたJSONのサンプルだぜ（＾▽＾）"
}
        </pre>


        <p>📄 src{{jsonFilePathAssets}}:</p>
        <pre class="coding-example mb-6">
{
    "#this-file": "アセットフォルダー下に置いたJSONのサンプルだぜ（＾▽＾）"
}
        </pre>


        <talk-balloon
            :src="oton2Src"
            :alt="oton2Alt"
            :name="oton2Name"
            :device="compatibleDevice1Ref?.device"
        >
            👆 その JSON ファイルを読み込むコードの１つに、<br/>
            👇 次のような書き方があるそうだぜ。
        </talk-balloon>


        <pre class="coding-example mb-6">
&lt;template&gt;
    &lt;v-btn @click="loadJson1" class="mt-6 mb-6"&gt;JSONファイル読込&lt;/v-btn&gt;

    &lt;pre&gt;&#123;&#123; jsonStr &#125;&#125;&lt;/pre&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
    import &#123; ref &#125; from 'vue';

    const jsonStr = ref("読み込み中...");

    async function loadJson1() &#123;
        try &#123;
            const response = <span class="red-marker">await fetch</span>("{{ jsonFilePathPublic }}");   // publicフォルダに置いたファイルにアクセスできる。
            if (!response.ok) throw new Error("Failed to fetch JSON");
            const data: any = await response.json();

            jsonStr.value = JSON.stringify(data, null, 4);

        &#125; catch (error) &#123;
            alert(`ERROR: sample.jsonファイル読込時。 $&#123;error&#125;`);
        &#125;
    &#125;;
&lt;/script&gt;
        </pre>


        <talk-balloon
            :src="oton2Src"
            :alt="oton2Alt"
            :name="oton2Name"
            :device="compatibleDevice1Ref?.device"
        >
            👆 これを実行した結果を見るには、<br/>
            👇 以下のボタンをクリックしてくれだぜ。
        </talk-balloon>

        <v-btn @click="loadJson1" class="mt-6 mb-6">JSONファイル読込</v-btn>

        <pre class="coding-example mb-6">
{{ json1Str }}
        </pre>


        <talk-balloon
            :src="oton2Src"
            :alt="oton2Alt"
            :name="oton2Name"
            :device="compatibleDevice1Ref?.device"
        >
            👇 他にも、Nuxt 3 から次のような書き方も増えたそうだぜ。
        </talk-balloon>


        <pre class="coding-example mb-6">
&lt;template&gt;
    &lt;pre&gt;&#123;&#123; jsonStr &#125;&#125;&lt;/pre&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
    import { ref } from 'vue';

    const jsonStr = ref("読み込み中...");

    const {
        data
    } = <span class="red-marker">await useFetch</span>&lt;any&gt;(
        jsonFilePathPublic,   // public フォルダー下のファイルへのパス
        {
            baseURL: '/',   // ？
            transform: (jsonObj: unknown): any => {    // やりたければ、データの変換処理

                // JSON がオブジェクト（辞書型）かどうかのチェック
                if (jsonObj && typeof jsonObj === 'object') {
                    return jsonObj;
                }

                // オブジェクト（辞書型）でなければ、空辞書を返す
                return {};
            },
            default: () => [], // エラー時のデフォルト値
        }
    );
    json2Str.value = data.value;
&lt;/script&gt;
        </pre>


        <talk-balloon
            :src="oton2Src"
            :alt="oton2Alt"
            :name="oton2Name"
            :device="compatibleDevice1Ref?.device"
        >
            👆 これを実行すると、<br/>
            👇 以下の通り。
        </talk-balloon>


<!-- 
        <pre class="coding-example mb-6">
{{ json2Str }}
        </pre>
-->
        <v-alert type="warning" title="免責！" text="useFetch() は Nuxt3 用です。 Tauri では使えません。" closable />


        <talk-balloon
            :src="hiyoko2Src"
            :alt="hiyoko2Alt"
            :name="hiyoko2Name"
            :device="compatibleDevice1Ref?.device">
            前者の fetch() と後者の useFetch() では、何が違うの？
        </talk-balloon>


        <talk-balloon
            :src="oton2Src"
            :alt="oton2Alt"
            :name="oton2Name"
            :device="compatibleDevice1Ref?.device"
        >
            前者の fetch() は、静的ページの初期値として使えない。<br/>
            だから、ページの読込完了のタイミングや、ボタンを押したタイミングで使うことになるぜ。<br/>
            <br/>
            public フォルダー下にアクセスできるのがメリットかな。
        </talk-balloon>


        <talk-balloon
            :src="oton2Src"
            :alt="oton2Alt"
            :name="oton2Name"
            :device="compatibleDevice1Ref?.device"
        >
            後者の useFetch() は、静的ページの初期値として使える。<br/>
            だから、サーバーサイドでプリレンダリングできる。<br/>
            <br/>
            Tauri で使えないので、ウェブアプリとデスクトップアプリを同じコードで書けないのがデメリットだな。
        </talk-balloon>


    </section>

    <button-to-go-to-top class="sec-1 pt-6"/>
    <h2>import()</h2>
    <section class="sec-2 pt-6">


        <talk-balloon
            :src="oton2Src"
            :alt="oton2Alt"
            :name="oton2Name"
            :device="compatibleDevice1Ref?.device"
        >
            第３の方法を説明する。<br/>
            まず、以下の設定をしておいてくれだぜ。<br/>
            <br/>
            プロジェクト・フォルダーの直下に public フォルダーがあって、また、<br/>
            Tauri デスクトップアプリには vite.config.ts が、<br/>
            Nuxt ウェブアプリには nuxt.config.ts ファイルがあるとするぜ。
        </talk-balloon>


        <p class="mt-6">📄 vite.config.ts（抜粋）:</p>
        <pre class="coding-example mb-6">
export default defineConfig(async () => ({
    resolve: {
        alias: {    // Tauri と Nuxt でエイリアスを合わせたい
            '@': path.resolve(__dirname, './src'),  // @ が src のエイリアスなのは Vue、特に Vite の習慣。
                                                    // 使用例： import Tile from '@/components/Tile.vue';

            // ~ が プロジェクトフォルダー全体のエイリアスなのは Nuxt の習慣。ここでは使わず、 @ の方に統一する。

            '/assets': path.resolve(__dirname, './src/assets'),
            '#public': path.resolve(__dirname, './public'), // #public が public のエイリアスなのは Nuxt の習慣。
        },
    },
}))
        </pre>


        <p class="mt-6">📄 nuxt.config.ts（抜粋）:</p>
        <pre class="coding-example mb-6">
export default defineNuxtConfig({
    alias: {
        '#public': './public', // public/ フォルダをエイリアス
    },
    dir: {
        assets: 'assets', // src/assets
        pages: 'pages', // src/pages
        plugins: 'plugins', // src/plugins
        public: '../public', // src から見て ../public
    },
})
        </pre>


        <talk-balloon
            :src="oton2Src"
            :alt="oton2Alt"
            :name="oton2Name"
            :device="compatibleDevice1Ref?.device"
        >
            👇 んで、次のようなコードを書く。
        </talk-balloon>


        <pre class="coding-example mb-6">
&lt;template&gt;
    &lt;pre&gt;&#123;&#123; jsonStr &#125;&#125;&lt;/pre&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
    import { onMounted, ref } from 'vue';

    const jsonStr = ref("読み込み中...");

    onMounted(async () => {
        try {
            // 動的インポート、ただし、ファイルパスは埋込み。
            const jsonObj = <span class="red-marker">await import</span>('/assets/data/making/sample-assets.json').then(module => module.default);
            json3Str.value = JSON.stringify(jsonObj, null, 4);

        } catch (err: unknown) {
            const errorMessage = err instanceof Error ? err.message : String(err);
            json3Str.value = `ERROR: ${errorMessage}`;
        }
    });
&lt;/script&gt;
        </pre>


        <talk-balloon
            :src="oton2Src"
            :alt="oton2Alt"
            :name="oton2Name"
            :device="compatibleDevice1Ref?.device"
        >
            👇 その結果は以下の通りだぜ。
        </talk-balloon>


        <pre class="coding-example mb-6">
{{ json3Str }}
        </pre>


        <talk-balloon
            :src="oton2Src"
            :alt="oton2Alt"
            :name="oton2Name"
            :device="compatibleDevice1Ref?.device"
        >
            👆 await import() は、サーバーサイドのプリレンダーでも、クライアントサイドでも使える。
        </talk-balloon>


        <talk-balloon
            :src="hiyoko2Src"
            :alt="hiyoko2Alt"
            :name="hiyoko2Name"
            :device="compatibleDevice1Ref?.device">
            じゃあ全部 await import() でいいんじゃないかなあ？
        </talk-balloon>


        <talk-balloon
            :src="oton2Src"
            :alt="oton2Alt"
            :name="oton2Name"
            :device="compatibleDevice1Ref?.device"
        >
            自分のプロジェクト内で見えるファイルに限られるけどな。
        </talk-balloon>


    </section>

    <br/>
    <h2>ソースコード</h2>
    <section class="sec-2">
        <source-link/>
    </section>

    <button-to-go-to-top class="sec-0 pt-6"/>
</template>

<script setup lang="ts">

    // ##############
    // # インポート #
    // ##############

    import { onMounted, ref } from 'vue';

    // ++++++++++++++++++++++++++++++++++
    // + インポート　＞　コンポーネント +
    // ++++++++++++++++++++++++++++++++++
    //
    // Tauri なら明示的にインポートを指定する必要がある。 Nuxt なら自動でインポートしてくれる場合がある。
    //

    import CompatibleDevice from '@/components/CompatibleDevice.vue'
    import SourceLink from '@/components/SourceLink.vue';
    import TalkBalloon from '@/components/TalkBalloon.vue';

    // ++++++++++++++++++++++++++
    // + インポート　＞　ページ +
    // ++++++++++++++++++++++++++

    import ButtonToBackToContents from '@/components/ButtonToBackToContents.vue';
    import ButtonToGoToTop from '@/components/ButtonToGoToTop.vue';
    import TheAppHeader from '../../the-app-header.vue';


    // ##########
    // # コモン #
    // ##########
    //
    // よく使う設定をまとめたもの。特に不変のもの。
    //

    import oton2Src from "@/assets/img/talk/202506__character__01-1951-kifuwarabeNoOton-o1o2o0.png";
    const oton2Alt = "きふわらべのお父ん２";
    const oton2Name = "きふわらべのお父ん";
    import kifuwarabe2Src from "@/assets/img/talk/202506__character__01-2013-kifuwarabe-o1o1o0.png";
    const kifuwarabe2Alt = "きふわらべ２";
    const kifuwarabe2Name = "きふわらべ";
    import hiyoko2Src from "@/assets/img/talk/202506__character__01-2025-hiyoko-o1o1o0.png";
    const hiyoko2Alt = "ひよこ２";
    const hiyoko2Name = "ひよこ";
    import kurokichi1Src from "@/assets/img/talk/202509__character__10--kurokichi.png";
    const kurokichi1Alt = "グロックの黒吉１";
    const kurokichi1Name = "グロックの黒吉";

    // ++++++++++++++++++++++++++++
    // + コモン　＞　外部ファイル +
    // ++++++++++++++++++++++++++++

    const jsonFilePathPublic = "/data/making/sample-public.json";  // public/data/making/sample.json
    const jsonFilePathAssets = "/assets/data/making/sample-assets.json";   // src/assets/data/making/sample.json


    // ################
    // # オブジェクト #
    // ################

    // ++++++++++++++++++++++++++++++++++
    // + オブジェクト　＞　装置の互換性 +
    // ++++++++++++++++++++++++++++++++++

    const compatibleDevice1Ref = ref<InstanceType<typeof CompatibleDevice> | null>(null);

    // ++++++++++++++++++++++++++++++++++++
    // + オブジェクト　＞　JSONファイル１ +
    // ++++++++++++++++++++++++++++++++++++

    const json1Str = ref("上のボタンを押してください...");

    async function loadJson1() {
        try {
            const response = await fetch(jsonFilePathPublic);   // publicフォルダに置いたファイルにアクセスできる。
            if (!response.ok) {
                throw new Error("Failed to fetch JSON");
            }
            const data: any = await response.json();

            json1Str.value = JSON.stringify(data, null, 4);

        } catch (error: unknown) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            json1Str.value = `ERROR: "${jsonFilePathPublic}" ファイル読込時。 ${errorMessage}`;
        }
    }

    // ++++++++++++++++++++++++++++++++++++
    // + オブジェクト　＞　JSONファイル２ +
    // ++++++++++++++++++++++++++++++++++++

    // useFetch は Nuxt3 用。 Tauri では使えない。
    // const json2Str = ref("読み込み中...");

    // const {
    //     data
    // } = await useFetch<any>(
    //     jsonFilePathPublic,   // public フォルダー下のファイルへのパス
    //     {
    //         baseURL: '/',   // ？
    //         transform: (jsonObj: unknown): any => {    // やりたければ、データの変換処理

    //             // JSON がオブジェクト（辞書型）かどうかのチェック
    //             if (jsonObj && typeof jsonObj === 'object') {
    //                 return jsonObj;
    //             }

    //             // オブジェクト（辞書型）でなければ、空辞書を返す
    //             return {};
    //         },
    //         default: () => [], // エラー時のデフォルト値
    //     }
    // );
    // json2Str.value = data.value;

    // ++++++++++++++++++++++++++++++++++++
    // + オブジェクト　＞　JSONファイル３ +
    // ++++++++++++++++++++++++++++++++++++

    const json3Str = ref("読み込み中...");

    onMounted(async () => {
        try {
            // 動的インポート、ただし、ファイルパスは埋込み。
            const jsonObj = await import('/assets/data/making/sample-assets.json').then(module => module.default);

            json3Str.value = JSON.stringify(jsonObj, null, 4);
        } catch (err: unknown) {
            const errorMessage = err instanceof Error ? err.message : String(err);
            json3Str.value = `ERROR: ${errorMessage}`;
        }
    });

</script>

<style scoped>
    @import '@/styles/notebook.css';
</style>
