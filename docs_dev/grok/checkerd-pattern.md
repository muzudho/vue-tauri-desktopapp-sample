# 数学なんだが、
市松模様を作ろうとしたら、
左上から右へタイルが i = 0, 1, 2 ... と並んでいるとき、
if (i % 2 == 0) で黒、
if (i % 2 == 1) で白とすれば、縞々は作れるだろ、

これを２段にすると、市松模様ではなくて、ストライプになってしまうんだぜ。
file, rank, width などを使って
if(x == 0) で黒、
if(x == 1) で白とするとき、 x はどんな式になるんだぜ（＾～＾）？




おっと、市松模様（チェックボードパターン）を作ろうとして、ストライプになっちゃったってのは、確かにハマりがちなポイントだな（＾～＾）。1段だと`i % 2`で黒白の縞模様ができるけど、2段以上にすると縞模様が続いちゃうってことは、行と列の両方を考慮してないからだぜ。市松模様は、行（rank）と列（file）の位置を使って、隣り合ったマスが交互に黒と白になるようにしないといけない。さっそく、どんな式で`x`を表現すればいいか考えてくぜ！

---

### **問題の整理**
- **市松模様**：チェッカーボードみたいに、隣り合ったマス（上下左右）が異なる色（黒と白）になるパターン。
- **入力**：
  - `file`：列のインデックス（0から始まる、左から右へ）。
  - `rank`：行のインデックス（0から始まる、上から下へ）。
  - `width`：1行のマスの数（ボードの幅）。
- **出力**：
  - `x`：黒（0）か白（1）を決める式。
  - `if (x == 0)`で黒、`if (x == 1)`で白。
- **問題**：`i % 2`だと、列インデックス`i`だけ見て色を決めるから、行が変わっても同じ列は同じ色になって、ストライプ（縞模様）になっちゃう。

市松模様を作るには、**行と列の両方**を考慮して、隣り合ったマスが異なる色になるようにする必要があるぜ。

---

### **市松模様の法則**
市松模様では、ボードのマス`(file, rank)`の色が以下のように決まる：
- あるマスが黒なら、その上下左右のマスは白。
- あるマスが白なら、その上下左右のマスは黒。
- 数学的に言うと、`(file, rank)`の**インデックスの和**（`file + rank`）が偶数か奇数かで色が決まる。

例えば、2x2のボードを考えると：
```
(file, rank) | file + rank | 色
-------------|-------------|-----
(0, 0)       | 0 + 0 = 0   | 黒
(1, 0)       | 1 + 0 = 1   | 白
(0, 1)       | 0 + 1 = 1   | 白
(1, 1)       | 1 + 1 = 2   | 黒
```
- `file + rank`が偶数なら黒（0）、奇数なら白（1）になるパターン。
- これなら、隣り合ったマス（`file`や`rank`が±1ずれる）と色が交互になる。

---

### **x の式**
`x`を`file`と`rank`を使って表現するなら、以下の式でOK：
```
x = (file + rank) % 2
```
- `x == 0`：黒（`file + rank`が偶数）。
- `x == 1`：白（`file + rank`が奇数）。

**なぜこれでいいか**：
- `file + rank`が偶数のときは、`(file, rank)`のマスは黒。
- `file + rank`が奇数のときは、`(file, rank)`のマスは白。
- 隣のマス（例：`(file+1, rank)`や`(file, rank+1)`）に行くと、`file + rank`の値が1増えるから、偶数↔奇数が切り替わり、色も黒↔白に変わる。

---

### **widthは必要？**
`width`は、ボードの幅（1行のマス数）を表してるけど、**市松模様の色を決めるだけなら`width`は不要**だ。なぜなら：
- 市松模様は局所的なパターン（上下左右のマスが交互）で決まる。
- `file`と`rank`だけで、各マスの位置が一意に決まるから、`width`は色決めには関係ない。

ただし、もし`i`（0から始まる通し番号）を使ってマスの位置を表現してる場合、例えば：
- `i = rank * width + file`（2次元ボードを1次元のインデックスに変換）
この場合、`file`と`rank`を`i`と`width`から逆算して：
```
file = i % width
rank = Math.floor(i / width)
```
そして、`x`はこうなる：
```
x = ((i % width) + Math.floor(i / width)) % 2
```
これでも市松模様の色が計算できるぜ。

---

### **コード例（Vue + Tauriでの実装例）**
Vueの`v-for`を使って市松模様を表示する場合、さっき作った`range`関数と組み合わせて、こんな感じで書ける：
```html
<template>
  <div v-for="r in range(0, height)" :key="r" class="row">
    <div
      v-for="f in range(0, width)"
      :key="f"
      :class="{ black: (f + r) % 2 === 0, white: (f + r) % 2 === 1 }"
    >
      <!-- マスの内容 -->
    </div>
  </div>
</template>

<script>
import { range } from '@/composables/range';

export default {
  data() {
    return {
      width: 8, // ボードの幅
      height: 8, // ボードの高さ
    };
  },
  methods: {
    range,
  },
};
</script>

<style>
.row {
  display: flex;
}
.black {
  background-color: black;
  width: 50px;
  height: 50px;
}
.white {
  background-color: white;
  width: 50px;
  height: 50px;
}
</style>
```
- `f`が`file`（列）、`r`が`rank`（行）。
- `(f + r) % 2`で色を決定。
- CSSで黒白のスタイルを適用。

---

### **なんでストライプになったのか**
元のコードで`if (i % 2 == 0)`を使ってたのは、**列インデックス`i`だけ見てた**からだ：
- `i`は列方向（`file`）の情報しか持ってない。
- 行（`rank`）が変わっても、`i % 2`は同じパターンを繰り返すから、列ごとに同じ色が並んでストライプになっちゃう。
- 市松模様にするには、行と列の両方を考慮して、`(file + rank) % 2`みたいにしないとダメだぜ。

---

### **確認用の図**
8x8のボードで、`(file + rank) % 2`の値を確認：
```
rank=0: [0, 1, 0, 1, 0, 1, 0, 1]  ← 黒, 白, 黒, 白, ...
rank=1: [1, 0, 1, 0, 1, 0, 1, 0]  ← 白, 黒, 白, 黒, ...
rank=2: [0, 1, 0, 1, 0, 1, 0, 1]  ← 黒, 白, 黒, 白, ...
...
```
これなら、隣のマス（上下左右）が必ず異なる色になるから、市松模様になる！

---

### **最終的な答え**
`x`の式は：
```
x = (file + rank) % 2
```
- `x == 0`で黒、`x == 1`で白。
- もし`i`（通し番号）を使ってるなら：
  ```
  x = ((i % width) + Math.floor(i / width)) % 2
  ```
これでバッチリ市松模様ができるぜ！（＾▽＾）

もしコードでハマったり、他のパターン（例えば3色とか！）試したいことがあれば教えてくれよ～。何か面白いことやってる？（＾～＾）
